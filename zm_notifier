#!/usr/bin/env python3

import sys
import os
import time
import cv2
import zm_util
from zm_api import ZMAPI
from zm_settings import Settings
from zm_monitor import Monitor
import zm_object_detection as Detectors
from zm_notification import Notification
from datetime import datetime


def resize_image(frame, dim, preserve_aspect=False):
    '''Resize an image with the option to preserve aspect ratio'''
    dimw = dim[0]
    dimh = dim[1]
    if preserve_aspect:
        h, w = frame.shape[:2]
        aspect = w/h
        if w > h:
            dimh = round(dimw/aspect)
        else:
            dimw = round(dimh/aspect)
    imsize = (dimw, dimh)
    return cv2.resize(frame, imsize)

def remove_tmp_files(tmp_analysis_filename):
    if tmp_analysis_filename is not None:
        try:
            if os.path.isfile(tmp_analysis_filename + ".txt"):
                os.remove(tmp_analysis_filename + ".txt")
        except IOError:
            zm_util.debug("Cannot delete {:s}.".format(tmp_analysis_filename + ".txt"), "stderr")

        try:
            if os.path.isfile(tmp_analysis_filename + ".jpg"):
                os.remove(tmp_analysis_filename + ".jpg")
        except IOError:
            zm_util.debug("Cannot delete {:s}.".format(tmp_analysis_filename + ".jpg"), "stderr")


if __name__ == "__main__":
    ################################################################################################
    # Setup
    ################################################################################################

    # Read config file static sections (all except monitors)
    st = Settings("/etc/zm_notifier.cfg")

    #  Log in to API and get list of all monitors
    zmapi = ZMAPI(st.local_server_address, st.username, st.password, st.world_server_address,
                  st.verify_ssl)
    if not zmapi.login():
        zm_util.debug("Login to the ZoneMinder API failed.", "stderr")
        sys.exit(1)

    # Read monitors settings
    api_monitors = zmapi.getMonitors()
    st.readMonitorSettings(api_monitors)

    # Set up notifiers
    notifier = Notification(st)

    # Set up object detection
    monitors = []
    for api_mon in api_monitors:
        # Reference to settings for this monitor
        mname = api_mon["name"]
        mid = api_mon["id"]
        ms = st.monitors[mname]
        detector = None
        # Set up the object detector for this monitor
        if ms["detect_objects"]:
            if ms["detection_model"] == "Darknet":
                classes_path = st.darknet_classes
                detector = Detectors.DetectorDarknet(mname, st.darknet_config, st.darknet_model,
                           ms["detect_classes"], ms["confidence_threshold"],
                           analysis_size=st.darknet_analysis_size)
            elif ms["detection_model"] == "MobileNetV3":
                classes_path = st.mobilenet_classes
                detector = Detectors.DetectorSSDMobileNetV3(mname, st.mobilenet_config,
                           st.mobilenet_model, ms["detect_classes"], ms["confidence_threshold"])
            elif ms["detection_model"] == "InceptionV2":
                classes_path = st.inception_classes
                detector = Detectors.DetectorTensorFlow(mname, st.inception_config,
                           st.inception_model, ms["detect_classes"], ms["confidence_threshold"],
                           analysis_size=st.inception_analysis_size)
            elif ms["detection_model"] == "HOG":
                classes_path = ""
                detector = Detectors.DetectorHOG(mname, st.hog_analysis_size, st.hog_winstride,
                           st.hog_scale)
            else:
                zm_util.debug("{:s} is not a valid detection model.".format(ms["detection_model"]),
                              "stderr")
                zmapi.logout()
                sys.exit(1)
            check = detector.initializeNetwork()
            check1 = detector.readClasses(classes_path)
            if not check or not check1:
                zm_util.debug("There was an error setting up detector for {:s}.".format(mname),
                              "stderr")
                sys.exit(1)

        # Append to the list
        if ms["check_events"]:
            monitors.append(Monitor(mname, mid, zmapi, detector, ms))
        else:
            zm_util.debug("Not appending monitor {:s} because check_events is False.".format(mname))

    ################################################################################################
    # Main loop
    ################################################################################################
    last_status = "Not running"
    last_runstate = "__None__"
    while True:
        sys.stdout.flush()
        sys.stderr.flush()

        # If ZoneMinder is not running, pause and start over
        if not zmapi.getDaemonStatus():
            if last_status == "Running":
                zm_util.debug("ZoneMinder is no longer running.")
                last_status = "Not running"
            time.sleep(st.stopped_timeout)
            continue

        # Get the active runstate
        runstates = zmapi.getRunStates()
        active_runstate = "__None__"
        for runstate in runstates:
            if runstate["active"]:
                active_runstate = runstate["name"]
                break
        if active_runstate != last_runstate:
            zm_util.debug("ZoneMinder is now in {:s} state.".format(active_runstate))
            last_runstate = active_runstate

        # Check if ZoneMinder is in the runstate for no notifications
        notify = True
        if st.no_notification_runstate != "":
            if active_runstate == st.no_notification_runstate:
                notify = False

        # Update status if needed
        if last_status == "Not running":
            zm_util.debug("ZoneMinder is now running.")
            last_status = "Running"

            # Pause to ensure the monitors' active statuses are set by the time we query
            time.sleep(5)

            # Update the active status and last event for all monitors
            for monitor in monitors:
                monitor.checkActive()
                monitor.getNewEvent()

            notifier.sendNotifications(f"Started. Checking events for {len(monitors)} monitors.", st.to_addresses,
                                       None, st.tmp_message_file[:-4])

        #just prepare format for message
        msg_detect = "*** Detected {:s} *** confidence {:.2f}"
        _msg = f"Started. Checking events for {len(monitors)} monitors."
        zm_util.debug(_msg, "stdout")


        # Loop through all monitors to check for new events
        for monitor in monitors:
            zm_util.debug(f"Last event for monitor {monitor.name} was  {monitor.latest_EventPictureID} .",
                          "stdout")

            if not monitor.active:
                # Check if previously inactive monitor has become active, then continue to the next
                # monitor.
                monitor.checkActive()
                continue

            # A monitor may have dropped out since the last time we checked
            if not monitor.checkActive():
                zm_util.debug("Warning: monitor {:s} has dropped out.".format(monitor.name),
                              "stderr")
                continue

            if not monitor.detect_objects:
                # nothing to do
                msg_head = "Motion detected, {:s}.".format(monitor.name)
                notifier.sendNotifications(msg_head, st.to_addresses, st.pushover_data)
                continue

            # Check for new event
            monitor.getNewEventPicturesList()
            if len(monitor.EventPicturesList) > 0 :
                zm_util.debug(f"--> New batch processing started ( size : {len(monitor.EventPicturesList)} )")
            current_event_id = 0
            for _index in range(len(monitor.EventPicturesList)):

                current_frame = monitor.EventPicturesList[_index]

                # restart for new event in batch
                if current_event_id != current_frame[monitor.EVENT_ID_POSITION]:
                    positive_detections_in_current_event = 0
                    current_event_id = current_frame[monitor.EVENT_ID_POSITION]

                # enhance printing with some figures :-)
                current_frame = list(current_frame)+ list([f"event {current_event_id}, {_index + 1}/"
                                                 f"{len(monitor.EventPicturesList)} "
                                                 f"scored {current_frame[monitor.FRAME_SCORE]}"])

                # check if its enough within this event/batch
                if positive_detections_in_current_event >= monitor.positive_detections_per_event_in_batch_limit:
                    # so, is enough , dont need to continue to check other frames within this event
                    zm_util.debug("{} positive detections achieved,"
                                  " skipping {}.".format(monitor.positive_detections_per_event_in_batch_limit,
                                                          current_frame[monitor.STATS_TO_PRINT]))
                    continue

                if not monitor.detect_objects:
                    zm_util.debug(f"Detect objects is not required for frame {current_frame[monitor.STATS_TO_PRINT]}")
                    continue

                frame, objclass, confidence, processed = monitor.detectObjects(current_frame)

                zm_util.debug(f"Confidence is {confidence} in frame {current_frame[monitor.STATS_TO_PRINT]}")

                # just remember last processed position/frame
                if processed:
                    # yes, it was analysed
                    monitor.latest_EventPictureID = current_frame[monitor.ID_POSITION]  # last frame.ID

                # do we have positive identification ?
                if objclass != "":
                    positive_detections_in_current_event = positive_detections_in_current_event + 1

                # Set some data for the message
                event_url = "" # TODO zmapi.getEventURL(eventid)
                msg_head = "Motion detected, {:s}, event {:d}.".format(monitor.name, current_event_id)
                msg_head += "\n" + event_url

                if frame is not None and notify:
                    # Send notifications. Possible situations:
                    # 1) detection on and object detected -> send message
                    # 2) detection on and no object detected ->
                    #    a) If notify_no_object, send anyway
                    #    b) Otherwise, ignore this event
                    # Send notifications if we detected something
                    if objclass != "":
                        # Scale and save the image to send in the notification
                        frame = resize_image(frame, st.analysis_image_size, preserve_aspect=True)
                        tmp_analysis_filenames = (f"{st.tmp_analysis_image[:-4]}_{current_event_id}_"
                                                  f"{current_frame[monitor.FRAME_ID_POSITION]}")
                        cv2.imwrite(tmp_analysis_filenames+".jpg", frame)
                        msg_detect = msg_detect.format(objclass, confidence)
                        zm_util.debug(msg_detect)
                        msg = msg_head + "\n" + msg_detect
                        notifier.sendNotifications(msg, st.to_addresses, st.pushover_data, tmp_analysis_filenames)
                        remove_tmp_files(tmp_analysis_filenames)
                    else:
                        zm_util.debug("No objects detected in {}.".format(current_frame[monitor.STATS_TO_PRINT]))
                        # Send notifications even with no detections if requested
                        if st.notify_no_object:
                            notifier.sendNotifications(msg_head, st.to_addresses,
                                                       st.pushover_data)

                else:
                    if frame is None:
                        zm_util.debug("No image. Skipping event {:d}.".format(current_event_id), "stderr")
                    elif not notify:
                        try:
                            msg = "In {:s} state; not sending notifications.".format(active_runstate)
                            zm_util.debug(msg)
                        except Exception as e:
                            zm_util.debug("Error : {}.".format(e), "stderr")

        # Wait for the next cycle
        time.sleep(st.running_timeout)

    ################################################################################################
    # Cleanup. We'll never get here, but we'll leave it in case a graceful stop feature is added.
    ################################################################################################
    zmapi.logout()
