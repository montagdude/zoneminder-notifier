#!/usr/bin/env python3

import sys
import time
import cv2
import zm_util
from zm_api import ZMAPI
from zm_settings import Settings
from zm_monitor import Monitor
import zm_object_detection as Detectors
from zm_notification import Notification


def resize_image(frame, dim, preserve_aspect=False):
    '''Resize an image with the option to preserve aspect ratio'''
    dimw = dim[0]
    dimh = dim[1]
    if preserve_aspect:
        h, w = frame.shape[:2]
        aspect = w/h
        if w > h:
            dimh = round(dimw/aspect)
        else:
            dimw = round(dimh/aspect)
    imsize = (dimw, dimh)
    return cv2.resize(frame, imsize)


if __name__ == "__main__":
    ################################################################################################
    # Setup
    ################################################################################################

    # Read config file static sections (all except monitors)
    st = Settings("/etc/zm_notifier.cfg")

    #  Log in to API and get list of all monitors
    zmapi = ZMAPI(st.local_server_address, st.username, st.password, st.world_server_address,
                  st.verify_ssl)
    if not zmapi.login():
        zm_util.debug("Login to the ZoneMinder API failed.", "stderr")
        sys.exit(1)

    # Read monitors settings
    api_monitors = zmapi.getMonitors()
    st.readMonitorSettings(api_monitors)

    # Set up notifiers
    notifier = Notification(st.tmp_message_file, st.tmp_analysis_image)

    # Set up only the object detectors needed
    detectors = {}
    classes_path_map = {}
    for mname in st.monitors:
        ms = st.monitors[mname]
        if ms["detect_objects"]:
            if ms["detection_model"] == "Darknet":
                if not "Darknet" in detectors:
                    darknet_detector = Detectors.DetectorDarknet("Darknet", st.darknet_config,
                                       st.darknet_model, st.darknet_detect_classes,
                                       st.darknet_confidence_threshold,
                                       analysis_size=st.darknet_analysis_size)
                    detectors["Darknet"] = darknet_detector
                    classes_path_map["Darknet"] = st.darknet_classes
            elif ms["detection_model"] == "MobileNetV3":
                if not "MobileNetV3"  in detectors:
                    mobilenet_detector = Detectors.DetectorSSDMobileNetV3("MobileNetV3",
                                         st.mobilenet_config, st.mobilenet_model,
                                         st.mobilenet_detect_classes,
                                         st.mobilenet_confidence_threshold)
                    detectors["MobileNetV3"] = mobilenet_detector
                    classes_path_map["MobileNetV3"] = st.mobilenet_classes
            elif ms["detection_model"] == "InceptionV2":
                if not "InceptionV2" in detectors:
                    inception_detector = Detectors.DetectorTensorFlow("InceptionV2",
                                         st.inception_config, st.inception_model,
                                         st.inception_detect_classes,
                                         st.inception_confidence_threshold,
                                         analysis_size=st.inception_analysis_size)
                    detectors["InceptionV2"] = inception_detector
                    classes_path_map["InceptionV2"] = st.inception_classes
            elif ms["detection_model"] == "HOG":
                if not "HOG" in detectors:
                    hog_detector = Detectors.DetectorHOG("HOG", st.hog_analysis_size,
                                   st.hog_winstride, st.hog_scale)
                    detectors["HOG"] = hog_detector
                    classes_path_map["HOG"] = ""
            else:
                zm_util.debug("Unsupported detection model {:s}.\n".format(ms["detection_model"]),
                              "stderr")
                sys.exit(1)

    # Read classes and initialize detector networks
    for detector_name, detector in detectors.items():
        check = detector.initializeNetwork()
        check1 = detector.readClasses(classes_path_map[detector_name])
        if not check or not check1:
            zm_util.debug("There was an error setting up {:s} detector.".format(detector_name),
                          "stderr")
            sys.exit(1)

    # Set up monitors
    monitors = []
    for api_mon in api_monitors:
        # Reference to settings for this monitor
        mname = api_mon["name"]
        mid = api_mon["id"]
        ms = st.monitors[mname]

        # Associate object detector
        detector = None
        if ms["detect_objects"]:
            detector = detectors[ms["detection_model"]]

        # Append to the list
        monitors.append(Monitor(mname, mid, zmapi, detector, ms["detect_objects"], ms["detect_in"]))

    ################################################################################################
    # Main loop
    ################################################################################################
    last_status = "Not running"
    while True:
        sys.stdout.flush()
        sys.stderr.flush()

        # If ZoneMinder is not running, pause and start over
        if not zmapi.getDaemonStatus():
            if last_status == "Running":
                zm_util.debug("ZoneMinder is no longer running.")
                last_status = "Not running"
            time.sleep(st.stopped_timeout)
            continue

        # Update status if needed
        if last_status == "Not running":
            zm_util.debug("ZoneMinder is now running.")
            last_status = "Running"

            # Pause to ensure the monitors' active statuses are set by the time we query
            time.sleep(5)

            # Update the active status and last event for all monitors
            for monitor in monitors:
                monitor.checkActive()
                monitor.getNewEvent()

        # Loop through all monitors to check for new events
        for monitor in monitors:
            if not monitor.active:
                # Check if previously inactive monitor has become active, then continue to the next
                # monitor.
                monitor.checkActive()
                continue

            # A monitor may have dropped out since the last time we checked
            if not monitor.checkActive():
                zm_util.debug("Warning: monitor {:s} has dropped out.".format(monitor.name),
                              "stderr")
                continue

            # Check for new event
            if monitor.getNewEvent():
                # Do object detection and get max score frame and detection info. If this monitor
                # is not set to do detection, this method just returns the max score frame and some
                # empty detection info.
                frame, objclass, confidence = monitor.detectObjects()

                # Set some data for the message
                eventid = monitor.latest_event['id']
                event_url = zmapi.getEventURL(eventid)
                msg_head = "Motion detected, {:s}, event {:d}.".format(monitor.name, eventid)
                zm_util.debug(msg_head)
                msg_head += "\n" + event_url
                msg_detect ="Detected {:s}, confidence {:.2f}"

                if frame is not None:
                    # Scale and save the image to send in the notification
                    frame = resize_image(frame, st.analysis_image_size, preserve_aspect=True)
                    cv2.imwrite(st.tmp_analysis_image, frame)

                    # Send notifications. Possible situations:
                    # 1) detection on and object detected -> send message
                    # 2) detection on and no object detected ->
                    #    a) If notify_no_object, send anyway
                    #    b) Otherwise, ignore this event
                    # 3) detection off -> send notification
                    if monitor.detect_objects:
                        # Send notifications if we detected something
                        if objclass != "":
                            msg_detect = msg_detect.format(objclass, confidence)
                            zm_util.debug(msg_detect)
                            msg = msg_head + "\n" + msg_detect
                            notifier.sendNotifications(msg, st.to_addresses, st.pushover_data)
                        else:
                            zm_util.debug("No objects detected in event {:d}.".format(eventid))
                            # Send notifications even with no detections if requested
                            if st.notify_no_object:
                                notifier.sendNotifications(msg_head, st.to_addresses,
                                                           st.pushover_data)

                    # Send notifications if object detection is off
                    else:
                        notifier.sendNotifications(msg_head, st.to_addresses, st.pushover_data)
                else:
                    zm_util.debug("No image. Skipping event {:d}.\n".format(eventid), "stderr")

        # Wait for the next cycle
        time.sleep(st.running_timeout)

    ################################################################################################
    # Cleanup. We'll never get here, but we'll leave it in case a graceful stop feature is added.
    ################################################################################################
    zmapi.logout()
